---
title: 存树形结构的几种表设计
date: 2016-10-08 14:52:25
tags: 设计
---

。有常规几种方案：
> 邻接表
> 路径枚举
> 嵌套集
> 闭包表
<!--more-->

## 邻接表
***
。使用一个 parent_id 来指向上一级节点
![](/images/20161008/邻接表.png)

。缺点：
> 无法完成树操作最普通的一项：查询一个节点的所有后代
> 查询和删除节点操作相对复杂

## 路径枚举
***
。将所有的祖先的信息联合组成一个字符串，并保存为每个节点的一个属性
![](/images/20161008/路径枚举.png)

。查询时，可以使用 like，比如 1/4/6/%
。优点

> 可以比较方便的查询到一个节点的祖先和后代，插入节点也相对简单

。缺点

> 数据库没有约束来确保路径格式的正确
> 不能保证路径中的节点确实存在
> 依赖程序的逻辑代码来维护路径的字符串，且验证字符串的正确的开销大
> VARCHAR长度有限，所以树不能无限扩展

## 嵌套表
***
。使用两个数字（nsleft、nsright）来编码每个节点，而不是记录其直接祖先
。nsleft 和 nsright 约束规则如下

> 1.nsleft 的数值小于该节点的所有后代的nsleft
> 2.sright 的数值大于该节点的所有后代nsright
> 3.具体的nsleft, nsright和该节点的id并没有直接的关联

![](/images/20161008/嵌套表.png)

。树结构：

![](/images/20161008/嵌套表树.png)

。优点

> 可以方便的找到一个节点的祖先和后代、可以较方便的删除节点

。缺点

> 一些简单查询（比如找父节点）、插入移动节点会复制一些
> 逻辑理解不方便

## 闭包表
***
。使用额外的一张表来存储path信息
。记录树种所有节点的关系，不仅仅是直接父子关系（并且增加一行节点指向自身）
。使用空间来交换时间
。表结构（只有2列，可以增加 length 来保留深度信息）：
![](/images/20161008/闭包表.png)
。树结构
![](/images/20161008/闭包表树.png)

。注意会保存以一个节点为祖先节点的所有节点，且会保留自身到自身的引用
。如果在有需要查询某个节点的直接子节点时，可以通过增加一个 length 来保留在树中的深度

## 对比
***
。表对比
![](/images/20161008/对比.png)

。细节
```
邻接表：     最方便的设计，理解简单
递归查询：   如果数据库支持 WITH 或者 CONNECT BY PRIOR 的递归查询，可以使用
路径枚举：   避免了一些邻接表的缺点，但是不能保证引用的完整性
嵌套集：     不能保证引用完整性，且理解相对复杂
闭包表：     通过引入额外的path表，功能、性能折中
```

## Reference
***
。《SQL Anti-patterm》
。https://segmentfault.com/a/1190000004443840
。http://cnn237111.blog.51cto.com/2359144/1226911
