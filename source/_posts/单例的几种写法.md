---
title: 单例的几种写法
date: 2018-06-11 13:14:32
tags: Java
---

本文记录Java种单例的编写方式

# 0x01 饿汉式(线程安全)
---
饿汉式单例的写法是比较简单的一种写法，案例如下
```java
public class Singleton {

    private static final Singleton INSTANCE = new Singleton();

    private Singleton(){
    }

    public static Singleton getInstance(){
        return INSTANCE;
    }

}
```
<!--more-->
。优点
> 代码逻辑简单

。缺点
> 在类加载的时候即会进行初始化，如果一个类在整个项目中并没有实际使用到，则无疑浪费了空间，其次，如果单例的是一个很复杂的对象，即构造函数中逻辑很多，则浪费的更加严重

# 0x02 懒汉式(线程不安全)
---
和饿汉式对应，懒汉式是一种能够延迟加载的方式，最简单的写法如下
```java
public class Singleton {

    private static Singleton instance = null;

    private Singleton(){

    }

    public static Singleton getInstance(){
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }

}
```
。上面的写法是一个线程不安全的单例，很好理解，即多线程情况，比如线程A在进行判断instance的时候，为空，但是线程B其实已经进行完了初始化，不过没有赋值而已
。那如果我们需要一个线程安全的懒汉式单例模式该怎么写呢？可以通过在getInstance方法上加上synchronized关键字来进行操作的同步化（但是有性能问题，即会增加所有getInstance整体的开销，不管instance是否真的已经有值）

# 0x03 懒汉式（双重检测)
---
针对上面说到的懒汉式的写法，且我们不希望对整个方法进行synchronized，其实我们可以只通过在判断instance为空和初始化上进行双重检验，来避免在整个getInstance上加synchronized
代码如下
```java
public class Singleton {

    private static Singleton instance = null;

    private Singleton(){

    }

    public static Singleton getInstance(){
        if(instance == null) {
            synchronized (Singleton.class){
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }

}
```
乍一看可能上面的写法感觉没有什么问题，其实不然。上面的写法依旧不是一个线程安全的单例。之所以线程不安全，涉及到了JVM的指令重排机制，instance = new Singleton()，实际在执行的时候，其实会拆分为3个步骤: 
1. memory = allocate();     //1：分配对象的内存空间
2. ctorInstance(memory);    //2：初始化对象
3. instance = memory;       //3：设置instance指向刚分配的内存地址 

正常情况下，上面的流程是没有问题的，但是，一旦发生指令重排(如2、3两步颠倒)，则多线程场景下又会出现问题
所以其实正确的双重检测、懒汉、线程安全的单例写法应该如下（即用volatile修饰instance，避免其指令重排）:
```java
public class Singleton {

    private static volatile Singleton instance = null;

    private Singleton(){

    }

    public static Singleton getInstance(){
        if(instance == null) {
            synchronized (Singleton.class){
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }

}
```

# 0x04 使用枚举（推荐方式且线程安全）
---
Java中枚举Enum类型是JDK5之后引入的一种类型，通过枚举，及其加载机制，其实我们可以很方便的构建一个保证线程安全、且懒加载、且JVM内绝对唯一的单例
写法如下：
```java
public class Singleton {


    private Singleton(){
    }

    public static Singleton getInstance(){
        return InnerSingleton.INSTANCE.getSingleton();
    }

    private enum  InnerSingleton{
        INSTANCE();

        private Singleton singleton = null;

        InnerSingleton(){
            singleton = new Singleton();
        }

        public Singleton getSingleton(){
            return singleton;
        }

    }

}
```

# Reference
---
[双重检查锁定与延迟初始化](http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization)